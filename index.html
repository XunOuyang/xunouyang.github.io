<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Ivan Xun Ouyang`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ivan Xun Ouyang&#96;s Blog">
<meta property="og:url" content="https://github.com/XunOuyang/xunouyang.github.io/blob/master/index.html">
<meta property="og:site_name" content="Ivan Xun Ouyang&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ivan Xun Ouyang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ivan Xun Ouyang`s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">Ivan Xun Ouyang`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/XunOuyang/xunouyang.github.io/blob/master"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Bitonic_Sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/04/13/Bitonic_Sort/" class="article-date">
  <time datetime="2020-04-13T04:33:27.003Z" itemprop="datePublished">2020-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/04/13/Bitonic_Sort/">Bitonic_Sort</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="双调排序-Bitonic-Sort"><a href="#双调排序-Bitonic-Sort" class="headerlink" title="双调排序 Bitonic Sort"></a>双调排序 Bitonic Sort</h3><p>双调排序是并行计算里面一个非常重要而且常见的应用。其思想跟归并排序一样，都是用了分治的思想。<br>为什么它叫做双调排序呢？因为Bitonic Sort 会先将一个数列排序成为前半段单调递增，后半段单调递减<br>的这么一个序列（中间过渡使用），这样一个前半段单调递增，后半段单调递减的序列，我们又把它叫做Bitonic sequence（双调序列）。</p>
<p>具体实现Bitonic Sort的操作如下：<br>下图所示是一个Bitonic Sort的示意图：</p>
<img src="/images/Bitonic_Sort/BitonicSort1.svg.png" width="800" hegiht="600">



<ol>
<li>先将任意序列变为双调序列。<br>假设有一个长为n的序列，n = 2 ^ k，那么，我们将其两两分组，假设n = 16，如下图所示，为了便于理解，我们假设数组从nums[1] 到nums[16]（这一点跟C/C++/Python 数组的起始index不同，只是为了方便）</li>
</ol>
<p>我们先进行第一步，那么一共有8组，所有奇数组的数字，比如 nums[1] 和 nums[2]（第一组）, 又或者 nums[5] 和nums[6]（第三组）等等，进行两两比较，比较的结果是，小的在前，大的在后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if nums[1] &gt; nums[2]:</span><br><span class="line">    nums[1], nums[2] &#x3D; nums[2], nums[1]</span><br></pre></td></tr></table></figure>
<p>同理，所有偶数组的数字，比如nums[3] 和 nums[4]，他们比较的结果相反，大的在上，小的在下。如此一来，nums[1], nums[2], nums[3],nums[4] 这4个数字就形成了一个bitonic sequence。</p>
<p>第二步，此时，我们将前面一步的8组结果，进行两两合并，成为4组数据，每一组里面呢，第一个数字跟第三个数字比较，第二个数字跟第四个数字比。如果是奇数组，那么依然是大的放到后面，小的数字放到前面。偶数组，大的在前，小的在后。<br>这样还不算完，第二步分成了两个部分，比较完了，nums[1]和nums[3]，nums[2]和nums[4]，我们还需要将nums[1]和nums[2]，nums[3]和nums[4] 再次进行小组比较。如此一来，第一组（nums[1]，nums[2],nums[3],nums[4]就成为了一个生序序列，而第二组成为了一个降序序列。</p>
<p>第三步，与前一步雷同，需要将4组数据进行两两合并，此时只有两个大组。</p>
<p>第四步，与前一步依然雷同，只是由于只有一组数据了，我们所做的，就是将一大组bitonic sequence进行梳理，整理成为一个升序序列。</p>
<p>Bitonic sort 的Python实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def bitonic_sort(up: bool, x: Sequence[int]) -&gt; List[int]:</span><br><span class="line">    &quot;&quot;&quot;Bitonic sort.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">      up: ascending if &#39;&#39;up&#39;&#39; is true, and decreasing otherwise.</span><br><span class="line">      x: A sequence of integers.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">      Sorted sequence of integers.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if len(x) &lt;&#x3D; 1:</span><br><span class="line">        return x</span><br><span class="line">    else: </span><br><span class="line">        first &#x3D; bitonic_sort(True, x[:len(x) &#x2F;&#x2F; 2])</span><br><span class="line">        second &#x3D; bitonic_sort(False, x[len(x) &#x2F;&#x2F; 2:])</span><br><span class="line">        return bitonic_merge(up, first + second)</span><br><span class="line"></span><br><span class="line">def bitonic_merge(up: bool, x) -&gt; List[int]: </span><br><span class="line">    # Assume input x is bitonic, and sorted list is returned </span><br><span class="line">    if len(x) &#x3D;&#x3D; 1:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        bitonic_compare(up, x)</span><br><span class="line">        first &#x3D; bitonic_merge(up, x[:len(x) &#x2F;&#x2F; 2])</span><br><span class="line">        second &#x3D; bitonic_merge(up, x[len(x) &#x2F;&#x2F; 2:])</span><br><span class="line">        return first + second</span><br><span class="line"></span><br><span class="line">def bitonic_compare(up: bool, x) -&gt; None:</span><br><span class="line">    dist &#x3D; len(x) &#x2F;&#x2F; 2</span><br><span class="line">    for i in range(dist):</span><br><span class="line">        if (x[i] &gt; x[i + dist]) &#x3D;&#x3D; up:</span><br><span class="line">            x[i], x[i + dist] &#x3D; x[i + dist], x[i]  # Swap</span><br></pre></td></tr></table></figure>


<p>那么，Bitonic Sort 的时间复杂度和空间复杂度分别都是什么样的呢？<br>假设S(n)是sort n个数字所需要的比较的次数，M(n)是合并n个数字所需要的比较的次数。<br>那么我们有，S(n) = 2*S(n) + M(n), M(n) = 2 * M(n) + n / 2，解出来可以得到<br>M(n) = O(nlog(n))<br>S(n) = O(n(log(n))^2)<br>粗一看，时间比merge sort或者quick sort还要慢，但是我们必须要搞明白，我们可以create n个thread<br>这样时间复杂度就只有O((log(n))^2) 了。<br>因为总共需要O(n(log(n))^2)次比较，每次比较都需要新开内存，所以space complexity是O(n(log(n))^2)。</p>
<p>如果大家感兴趣的，也可以看一看bitonic sort 在cuda里的实现，上述代码只是简单的讲一下bitonic实现的原理，<br>但是实际上并不会比merge sort或者quick sort更快，因为我们既没有用到多线程，也没有使用GPU。</p>
<p>CUDA 实现Bitnoic Sort: <a href="https://gist.github.com/mre/1392067" target="_blank" rel="noopener">https://gist.github.com/mre/1392067</a></p>
<p>MPI 实现Bitnoic Sort: <a href="https://github.com/orestisfl/mpi_bitonic_sort">https://github.com/orestisfl/mpi_bitonic_sort</a></p>
<h2 id="reference："><a href="#reference：" class="headerlink" title="reference："></a>reference：</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Bitonic_sorter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bitonic_sorter</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/04/13/Bitonic_Sort/" data-id="ck8xzbmhg0000m1sj43n5dxtg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Parallel Computing 2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/29/Parallel%20Computing%202/" class="article-date">
  <time datetime="2020-03-29T16:48:25.000Z" itemprop="datePublished">2020-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Parallel-Computing/">Parallel Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/29/Parallel%20Computing%202/">Parallel Computing 2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SCAN-and-Reduce"><a href="#SCAN-and-Reduce" class="headerlink" title="SCAN and Reduce"></a>SCAN and Reduce</h1><h3 id="SCAN-application-—-SCAN-in-quicksort"><a href="#SCAN-application-—-SCAN-in-quicksort" class="headerlink" title="SCAN application — SCAN in quicksort"></a>SCAN application — SCAN in quicksort</h3><p>Let`s say if we have an array A[0:11] = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9]<br>How do we make use parallel computing to do the quick sort here.<br>In order to do a quick sort, we should first find a number as a pivot point.<br>Let take the A[9] = 3 as the pivot point.<br>[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9]<br>                            ^<br>                            |<br>                           pivot<br>so we can load each number into a memory cell, and compare all the number with A[9].<br>We create an array to store the result – if the number if greater than the pivot number, we assign it to 0, otherwise 1.</p>
<p>so we have<br>original array =   [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9]<br>A[:] &lt;= pivot ?    [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]<br>scan the array<br>above we will have:[0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]</p>
<p>we can easily get the L[0:4] = [3, 1, 1, 2, 3]</p>
<pre><code>Psedo code:
1. first we compute the flags, 
2. do a scan to get the indices
3. </code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/29/Parallel%20Computing%202/" data-id="ck8bu1s5w0001shsj8f8rd4w8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Multi-Threading in Python" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/28/Multi-Threading%20in%20Python/" class="article-date">
  <time datetime="2020-03-29T03:48:25.000Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Parallel-Computing/">Parallel Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/28/Multi-Threading%20in%20Python/">Multi Threading in Python</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This article will introduce the most basic 5 different multi-threading methods implementation in Python. We will use a very simple example to show how to make use of these 5 different methods to solve a problem.</p>
<h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><p>Barrier objects in python are used to wait for a fixed number of thread to complete execution before any particular thread can proceed forward with the execution of the program. Each thread calls wait() function upon reaching the barrier. The barrier is responsible for keeping track of the number of wait() calls. If this number goes beyond the number of threads for which the barrier was initialized with, then the barrier gives a way to the waiting threads to proceed on with the execution. All the threads at this point of execution, are simultaneously released.</p>
<p>There are several main methods available from this object:</p>
<h5 id="parties"><a href="#parties" class="headerlink" title="parties()"></a>parties()</h5><p>A number of threads required to reach the common barrier point.</p>
<h4 id="n-waiting"><a href="#n-waiting" class="headerlink" title="n_waiting()"></a>n_waiting()</h4><p>Number of threads waiting in the common barrier point</p>
<h5 id="broken"><a href="#broken" class="headerlink" title="broken()"></a>broken()</h5><p>A boolean value, True- if the barrier is in the broken state else False.<br>####wait( timeout = None)<br>Wait until notified or a timeout occurs. If the calling thread has not acquired the lock when this method is called, a runtime error is raised.<br>This method releases the underlying lock and then blocks until it is awakened by a notify() or notify_all() method call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns.<br>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</p>
<h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h5><p>Set or return the barrier to the default state .i.e. empty state. And threads waiting on it will receive the BrokenBarrierError.</p>
<h5 id="bort"><a href="#bort" class="headerlink" title="bort()"></a>bort()</h5><p>This will put the barrier into a broken state. This causes all the active threads or any future calls to wait() to fail with the BrokenBarrierError.<br>Here is a program to show how barrier works in python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import threading </span><br><span class="line">  </span><br><span class="line">barrier &#x3D; threading.Barrier(3) </span><br><span class="line">  </span><br><span class="line">class thread(threading.Thread): </span><br><span class="line">    def __init__(self, thread_ID): </span><br><span class="line">        threading.Thread.__init__(self) </span><br><span class="line">        self.thread_ID &#x3D; thread_ID </span><br><span class="line">    def run(self): </span><br><span class="line">        print(str(self.thread_ID) + &quot;\n&quot;) </span><br><span class="line">        print(&quot;Parties &#x3D; &quot; + str(barrier.parties) + &quot;\n&quot;) </span><br><span class="line">        print(&quot;n_waiting &#x3D; &quot; + str(barrier.n_waiting) + &quot;\n&quot;) </span><br><span class="line">        barrier.wait() </span><br><span class="line">          </span><br><span class="line">thread1 &#x3D; thread(100) </span><br><span class="line">thread2 &#x3D; thread(101) </span><br><span class="line">  </span><br><span class="line">thread1.start() </span><br><span class="line">thread2.start() </span><br><span class="line">  </span><br><span class="line">barrier.wait() </span><br><span class="line">  </span><br><span class="line">print(str(barrier.broken) + &quot;\n&quot;) </span><br><span class="line">barrier.reset() </span><br><span class="line">print(&quot;n_waiting after reset &#x3D; &quot; + str(barrier.n_waiting)) </span><br><span class="line">barrier.abort() </span><br><span class="line">print(&quot;End&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>The threading module of Python includes locks as a synchronization tool. A lock has two states:<br>locked and unlocked.<br>A lock can be locked using the acquire() method. Once a thread has acquired the lock, all subsequent attempts to acquire the lock are blocked until it is released. The lock can be released using the release() method.</p>
<p>Calling the release() method on a lock, in an unlocked state, results in an error.</p>
<p>Let us take an example to see how to make use lock to solve a race condition problem.</p>
<p>Race condition is a significant problem in concurrent programming. The condition occurs when one thread tries to modify a shared resource at the same time that another thread is modifying that resource – t​his leads to garbled output, which is why threads need to be synchronized.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Importing the threading module</span><br><span class="line">import threading </span><br><span class="line"># Declraing a lock</span><br><span class="line">lock &#x3D; threading.Lock()</span><br><span class="line">deposit &#x3D; 100</span><br><span class="line"># Function to add profit to the deposit</span><br><span class="line">def add_profit(): </span><br><span class="line">    global deposit</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        deposit &#x3D; deposit + 10</span><br><span class="line">        lock.release()</span><br><span class="line"># Function to deduct money from the deposit</span><br><span class="line">def pay_bill(): </span><br><span class="line">    global deposit</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        deposit &#x3D; deposit - 10</span><br><span class="line">        lock.release()</span><br><span class="line"># Creating threads</span><br><span class="line">thread1 &#x3D; threading.Thread(target &#x3D; add_profit, args &#x3D; ())</span><br><span class="line">thread2 &#x3D; threading.Thread(target &#x3D; pay_bill, args &#x3D; ())</span><br><span class="line"># Starting the threads  </span><br><span class="line">thread1.start() </span><br><span class="line">thread2.start() </span><br><span class="line"># Waiting for both the threads to finish executing </span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"># Displaying the final value of the deposit</span><br><span class="line">print(deposit)</span><br></pre></td></tr></table></figure>


<p>Let us use a list variable to record the whole process how deposit changes alone the way.<br>If we do not have the lock.acquire() and lock.release(), the result may looks like below when there is no lock.acquire() and lock.release() present:</p>
<p>With the usage of lock.acquire() and lock.release(), it will be like:</p>
<h1 id="Semaphore-Object"><a href="#Semaphore-Object" class="headerlink" title="Semaphore Object"></a>Semaphore Object</h1><p>A semaphore manages an internal counter which is decremented by each acquire() call and incremented by each release() call. The counter can never go below zero; when acquire() finds that it is zero, it blocks, waiting until some other thread calls release().</p>
<p>There are several main methods available from this object:</p>
<h5 id="acquire-blocking-True-timeout-None"><a href="#acquire-blocking-True-timeout-None" class="headerlink" title="acquire(blocking=True, timeout=None):"></a>acquire(blocking=True, timeout=None):</h5><h5 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h5><h1 id="Mutex-Lock-VS-Semaphore"><a href="#Mutex-Lock-VS-Semaphore" class="headerlink" title="Mutex(Lock) VS Semaphore"></a>Mutex(Lock) VS Semaphore</h1><p>As we can tell, the methods we have from Lock instance are pretty similar to the methods we have from Semaphore. Then what is the difference between Mutex and Semaphore ?</p>
<p>Mutex is a mutual exclusion object that synchronizes access to a resource. It is created with a unique name at the start of a program. The Mutex is a locking mechanism that makes sure only one thread can acquire the Mutex at a time and enter the critical section. This thread only releases the Mutex when it exits the critical section.</p>
<p>A semaphore is a signalling mechanism and a thread that is waiting on a semaphore can be signaled by another thread. This is different than a mutex as the mutex can be signaled only by the thread that called the wait function.</p>
<p>There are mainly two types of semaphores i.e. counting semaphores and binary semaphores.</p>
<p>Counting Semaphores are integer value semaphores and have an unrestricted value domain. These semaphores are used to coordinate the resource access, where the semaphore count is the number of available resources.</p>
<p>The binary semaphores are like counting semaphores but their value is restricted to 0 and 1. The wait operation only works when the semaphore is 1 and the signal operation succeeds when semaphore is 0.</p>
<h1 id="Event-Object"><a href="#Event-Object" class="headerlink" title="Event Object"></a>Event Object</h1><p>One thread can signal an event and other threads wait for it.<br>There are several main methods available from this object:</p>
<h5 id="isSet"><a href="#isSet" class="headerlink" title="isSet()"></a>isSet()</h5><p>Return true if and only if the internal flag is true</p>
<h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call wait() once the flag is true will not block at all.</p>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>Reset the internal flag to false. Subsequently, threads calling wait() will block until set() is called to set the internal flag to true again.</p>
<h4 id="wait-timeout-in-seconds"><a href="#wait-timeout-in-seconds" class="headerlink" title="wait([timeout in seconds])"></a>wait([timeout in seconds])</h4><p>Block until the internal flag is true.</p>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>There are several main methods available from this object:</p>
<h5 id="Condition-lock"><a href="#Condition-lock" class="headerlink" title="Condition([lock])"></a>Condition([lock])</h5><p>If the lock argument is given and not None, it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock.</p>
<h5 id="acquire-args"><a href="#acquire-args" class="headerlink" title="acquire(*args)"></a>acquire(*args)</h5><p>Acquire the underlying lock. This method calls the corresponding method on the underlying lock; the return value is whatever that method returns.</p>
<h5 id="release-1"><a href="#release-1" class="headerlink" title="release ()"></a>release ()</h5><p>Release the underlying lock. This method calls the corresponding method on the underlying lock; there is no return value.</p>
<h5 id="wait-timeout"><a href="#wait-timeout" class="headerlink" title="wait([timeout])"></a>wait([timeout])</h5><h5 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h5><p>Wake up a thread waiting on this condition, if any. This must only be called when the calling thread has acquired the lock.</p>
<h5 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h5><p>Wake up all threads waiting on this condition.</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>Ok. At the end, let see a problem which can be solved by making use Brutal force, Barrier, Event, Condition, Lock and Semaphore.</p>
<p>Problem description<br>Suppose we have a class:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def first():</span><br><span class="line">	printFirst()</span><br><span class="line">    def second():</span><br><span class="line">        printSecond()    </span><br><span class="line">    def third():</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<p>Now we have an instance of Foo which will be passed to 3 different threads. Thread A will call first(), thread B will call second(), thread C will call third(). Design a mechanism to ensure that the second() is executed after first(), third() is executed after second().</p>
<h3 id="Brutal-Force"><a href="#Brutal-Force" class="headerlink" title="Brutal Force"></a>Brutal Force</h3><p>We definite can make use of a very brutal force way to solve this problem by setting a flag with in the class. Until the flag was trigger, we are not able to move forward. Refer to the code below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.status &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        # printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">        while self.status !&#x3D; 0:</span><br><span class="line">            time.sleep(0.001)</span><br><span class="line">        printFirst()</span><br><span class="line">        self.status &#x3D; 1</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        # printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        while self.status !&#x3D; 1:</span><br><span class="line">            time.sleep(0.001)</span><br><span class="line">        printSecond()</span><br><span class="line">        self.status &#x3D; 2</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        # printThird() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        while self.status !&#x3D; 2:</span><br><span class="line">            time.sleep(0.001)</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Barrier-1"><a href="#Barrier-1" class="headerlink" title="Barrier"></a>Barrier</h3><p>Raise two barriers. Both wait for two threads to reach them.</p>
<p>First thread can print before reaching the first barrier. Second thread can print before reaching the second barrier. Third thread can print after the second barrier.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from threading import Barrier</span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.first_barrier &#x3D; Barrier(2)</span><br><span class="line">        self.second_barrier &#x3D; Barrier(2)</span><br><span class="line">            </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.first_barrier.wait()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        self.first_barrier.wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.second_barrier.wait()</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        self.second_barrier.wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Lock-Mutex"><a href="#Lock-Mutex" class="headerlink" title="Lock (Mutex)"></a>Lock (Mutex)</h3><p>Start with two locked locks. First thread unlocks the first lock that the second thread is waiting on. Second thread unlocks the second lock that the third thread is waiting on.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from threading import Lock</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.locks &#x3D; (Lock(),Lock())</span><br><span class="line">        self.locks[0].acquire()</span><br><span class="line">        self.locks[1].acquire()</span><br><span class="line">        </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.locks[0].release()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        with self.locks[0]:</span><br><span class="line">            printSecond()</span><br><span class="line">            self.locks[1].release()</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        with self.locks[1]:</span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Start with two closed gates represented by 0-value semaphores. Second and third thread are waiting behind these gates. When the first thread prints, it opens the gate for the second thread. When the second thread prints, it opens the gate for the third thread.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from threading import Semaphore</span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.gates &#x3D; (Semaphore(0),Semaphore(0))</span><br><span class="line">        </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.gates[0].release()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        with self.gates[0]:</span><br><span class="line">            printSecond()</span><br><span class="line">            self.gates[1].release()</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        with self.gates[1]:</span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>Set events from first and second threads when they are done. Have the second thread wait for first one to set its event. Have the third thread wait on the second thread to raise its event.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from threading import Event</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.done &#x3D; (Event(),Event())</span><br><span class="line">        </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.done[0].set()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        self.done[0].wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.done[1].set()</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        self.done[1].wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Condition-1"><a href="#Condition-1" class="headerlink" title="Condition"></a>Condition</h3><p>Have all three threads attempt to acquire an RLock via Condition. The first thread can always acquire a lock, while the other two have to wait for the order to be set to the right value. First thread sets the order after printing which signals for the second thread to run. Second thread does the same for the third.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from threading import Condition</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.exec_condition &#x3D; Condition()</span><br><span class="line">        self.order &#x3D; 0</span><br><span class="line">        self.first_finish &#x3D; lambda: self.order &#x3D;&#x3D; 1</span><br><span class="line">        self.second_finish &#x3D; lambda: self.order &#x3D;&#x3D; 2</span><br><span class="line"></span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        with self.exec_condition:</span><br><span class="line">            printFirst()</span><br><span class="line">            self.order &#x3D; 1</span><br><span class="line">            self.exec_condition.notify(2)</span><br><span class="line"></span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        with self.exec_condition:</span><br><span class="line">            self.exec_condition.wait_for(self.first_finish)</span><br><span class="line">            printSecond()</span><br><span class="line">            self.order &#x3D; 2</span><br><span class="line">            self.exec_condition.notify()</span><br><span class="line"></span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        with self.exec_condition:</span><br><span class="line">            self.exec_condition.wait_for(self.second_finish)</span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure>
<p>Referrence:<br><a href="https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation" target="_blank" rel="noopener">https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation</a><br><a href="https://www.geeksforgeeks.org/barrier-objects-python/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/barrier-objects-python/</a><br><a href="https://www.educative.io/edpresso/what-are-locks-in-python" target="_blank" rel="noopener">https://www.educative.io/edpresso/what-are-locks-in-python</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/28/Multi-Threading%20in%20Python/" data-id="ck8bu1s4a0000shsj0k761x51" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/27/hello-world/" class="article-date">
  <time datetime="2020-03-28T00:59:31.373Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/27/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/27/hello-world/" data-id="ck8az0g7t0002d7sjcgdt1lvo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Lidar-Data-PostProcessing1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/25/Lidar-Data-PostProcessing1/" class="article-date">
  <time datetime="2020-03-26T03:48:25.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Autonomous-Driving/">Autonomous Driving</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/25/Lidar-Data-PostProcessing1/">Lidar Data PostProcessing1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/25/Lidar-Data-PostProcessing1/" data-id="ck8az0g7n0000d7sjg4u2enez" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Parallel Computing1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/25/Parallel%20Computing1/" class="article-date">
  <time datetime="2020-03-26T03:48:25.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Parallel-Computing/">Parallel Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/25/Parallel%20Computing1/">Parallel Computing 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In order to understand how parallel computing works, we have to understand a few concepts.<br>A multithreaded computation can be represetned by a Directed Acyclic Graph of vertices. Each vertex represents the executtion of an instruction.<br>First of all, let`s take a look at 2 concepts:<br>Cost model: Work and Span:</p>
<h5 id="Work"><a href="#Work" class="headerlink" title="Work"></a>Work</h5><p>The total work that will be executed by all the processors.<br>If we consider the whole process that a computer finish all the tasks as a Directed Acyclic Graph, then work is the total number of all vertices of the DAG.</p>
<p>Span: sometime we call it depth, is the length of the longest path of the<br>DAG(critical path). </p>
<p>See the picture below, work == 21, span == 8<br><img src="/images/Parallel Computing1/work_and_span.jpg" width="400" hegiht="400"></p>
<p>Brent`s Theorem:<br>Brent`s theorem is the theorem to give the upper bound and lower bound of the time that expires between the start of the computation and its end. Let us<br>denote it as Tp, denote total work as W, Span as D, number of processors as N.<br><img src="/images/Parallel Computing1/brent_theorem.jpg" width="400" hegiht="400"></p>
<p>Then we can easily have:<br>Tp =  ∑(1 to D)(floor(Wi-1)/P) + 1<br>based on the properties of ceiling and floor operation, we have<br>max(D, ceiling(W/N)) &lt;= Tp &lt;= (W-D)/N + D</p>
<p>par-for loop:<br>(parallel for loop, sometimes people call it for-any loop or for-all loop)<br>All iterations are independent to each other.</p>
<img src="/images/Parallel Computing1/par_for.jpg" width="400" height="400"/>

<p>The DAG above shows how does a offline scheduling problem works. In reality, we might don`t have full knowledge of the DAG. Instead, the DAG unfolds as we run the program. Futhermore, we are interested in not only minimizing the length of the schedule but also the work and time it takes to compute the schedule. These 2 conditions defin the online scheduling problem.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/25/Parallel%20Computing1/" data-id="ck8az0g7r0001d7sjfj0qhd22" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="categories/Autonomous-Driving/">Autonomous Driving</a></li><li class="category-list-item"><a class="category-list-link" href="categories/Parallel-Computing/">Parallel Computing</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2020/04/13/Bitonic_Sort/">Bitonic_Sort</a>
          </li>
        
          <li>
            <a href="2020/03/29/Parallel%20Computing%202/">Parallel Computing 2</a>
          </li>
        
          <li>
            <a href="2020/03/28/Multi-Threading%20in%20Python/">Multi Threading in Python</a>
          </li>
        
          <li>
            <a href="2020/03/27/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="2020/03/25/Lidar-Data-PostProcessing1/">Lidar Data PostProcessing1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Ivan Xun Ouyang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="fancybox/jquery.fancybox.css">

  
<script src="fancybox/jquery.fancybox.pack.js"></script>




<script src="js/script.js"></script>




  </div>
</body>
</html>