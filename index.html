<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Ivan Xun Ouyang`s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ivan Xun Ouyang&#96;s Blog">
<meta property="og:url" content="https://github.com/XunOuyang/xunouyang.github.io/blob/master/index.html">
<meta property="og:site_name" content="Ivan Xun Ouyang&#96;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ivan Xun Ouyang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ivan Xun Ouyang`s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">Ivan Xun Ouyang`s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/XunOuyang/xunouyang.github.io/blob/master"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hungarian algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/07/12/hungarian%20algorithm/" class="article-date">
  <time datetime="2020-07-12T20:59:25.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Autonomous-Driving/">Autonomous Driving</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/07/12/hungarian%20algorithm/">Hungarian Algorithm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The Hungarian method is a combinatorial optimization algorithm that solves the assignment problem in polynomial time and which anticipated later primal-dual methods. Why we bring it up here today? It is a widely used algorithm in data point association which means it can be also used in autonomous driving for multi-target tracking.</p>
<p>In order to have a good understanding in Hungarian Algorithm, we will have to first understand a few concepts:</p>
<h2 id="Bipartite-graph"><a href="#Bipartite-graph" class="headerlink" title="Bipartite graph"></a>Bipartite graph</h2><p>A bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. Let us take a look at a example as below:<br><img src="/images/Hungarian_Algorithm/1.png"/><br><img src="/images/Hungarian_Algorithm/2.png"/><br><img src="/images/Hungarian_Algorithm/3.png"/><br><img src="/images/Hungarian_Algorithm/4.png"/><br>Let`s take a look at Fig. 1. This is a bipartite graph.</p>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>A vertex is matched (or saturated) if it is an endpoint of one of the edges in the matching. Otherwise the vertex is unmatched.</p>
<h2 id="Maximal-matching"><a href="#Maximal-matching" class="headerlink" title="Maximal matching"></a>Maximal matching</h2><p>A maximal matching is a matching M of a graph G that is not a subset of any other matching.</p>
<h2 id="Maximum-matching"><a href="#Maximum-matching" class="headerlink" title="Maximum matching"></a>Maximum matching</h2><p>In graph theory, a maximum matching is a matching that contains the largest possible number of edges.</p>
<h2 id="Perfect-matching"><a href="#Perfect-matching" class="headerlink" title="Perfect matching"></a>Perfect matching</h2><p>If one matching in all the matching of a graph, can make all the vertices matched, then we call this matching a perfect matching. It is very commonly seen that a graph does not have any perfect matching. </p>
<h2 id="Alternating-Path"><a href="#Alternating-Path" class="headerlink" title="Alternating Path"></a>Alternating Path</h2><p>It is a path that begins with an unmatched vertex and[2] whose edges belong alternately to the matching and not to the matching.</p>
<h2 id="Augmenting-Path"><a href="#Augmenting-Path" class="headerlink" title="Augmenting Path"></a>Augmenting Path</h2><p>It is an alternating path that starts from and ends on free (unmatched) vertices.</p>
<p>From Fig 5, we have a augmenting path like Fig 6.<br><img src="/images/Hungarian_Algorithm/5.png" > <img src="/images/Hungarian_Algorithm/6.png" >  </p>
<h3 id="Algorithm-details"><a href="#Algorithm-details" class="headerlink" title="Algorithm details"></a>Algorithm details</h3><p>Let us take an example:</p>
<h5 id="We-are-trying-to-match-the-vertices-1-2-3-4-with-a-b-c-d-The-relationship-between-vertices-is-shown-as-below"><a href="#We-are-trying-to-match-the-vertices-1-2-3-4-with-a-b-c-d-The-relationship-between-vertices-is-shown-as-below" class="headerlink" title="We are trying to match the vertices 1,2,3,4 with a,b,c,d. The relationship between vertices is shown as below:"></a>We are trying to match the vertices 1,2,3,4 with a,b,c,d. The relationship between vertices is shown as below:</h5><img src="/images/Hungarian_Algorithm/example1.jpeg" >

<h5 id="We-first-assign-1-to-a-we-mark-it-as-red-indicate-that-it-is-a-match"><a href="#We-first-assign-1-to-a-we-mark-it-as-red-indicate-that-it-is-a-match" class="headerlink" title="We first assign 1 to a, we mark it as red indicate that it is a match."></a>We first assign 1 to a, we mark it as red indicate that it is a match.</h5><img src="/images/Hungarian_Algorithm/example2.jpeg" >

<h5 id="Then-we-match-2-with-b"><a href="#Then-we-match-2-with-b" class="headerlink" title="Then we match 2 with b."></a>Then we match 2 with b.</h5><img src="/images/Hungarian_Algorithm/example3.jpeg" >

<h5 id="We-are-trying-to-match-3-a-vertice-however-we-find-that-a-and-b-both-are-matched-with-other-vertices-So-we-are-trying-to-reassign-1-to-another-vertice-We-mark-it-as-blue"><a href="#We-are-trying-to-match-3-a-vertice-however-we-find-that-a-and-b-both-are-matched-with-other-vertices-So-we-are-trying-to-reassign-1-to-another-vertice-We-mark-it-as-blue" class="headerlink" title="We are trying to match 3 a vertice however we find that a and b both are matched with other vertices. So we are trying to reassign 1 to another vertice. We mark it as blue."></a>We are trying to match 3 a vertice however we find that a and b both are matched with other vertices. So we are trying to reassign 1 to another vertice. We mark it as blue.</h5><p>&lt;img src=”/images/Hungarian_Algorithm/example4.jpeg” “&gt;</p>
<h5 id="Similarly-we-find-that-we-cannot-assign-1-to-another-vertice-because-b-is-occupied-too-We-have-to-unassign-b-to-2-and-assign-b-to-2-We-get-c-for-2-instead"><a href="#Similarly-we-find-that-we-cannot-assign-1-to-another-vertice-because-b-is-occupied-too-We-have-to-unassign-b-to-2-and-assign-b-to-2-We-get-c-for-2-instead" class="headerlink" title="Similarly, we find that we cannot assign 1 to another vertice because b is occupied too. We have to unassign b to 2 and assign b to 2. We get c for 2 instead."></a>Similarly, we find that we cannot assign 1 to another vertice because b is occupied too. We have to unassign b to 2 and assign b to 2. We get c for 2 instead.</h5><p>&lt;img src=”/images/Hungarian_Algorithm/example5.jpeg” “&gt;</p>
<h5 id="Now-1-gets-b-which-is-marked-as-red-Similarly-2-gets-c-3-gets-a"><a href="#Now-1-gets-b-which-is-marked-as-red-Similarly-2-gets-c-3-gets-a" class="headerlink" title="Now 1 gets b which is marked as red. Similarly 2 gets c, 3 gets a."></a>Now 1 gets b which is marked as red. Similarly 2 gets c, 3 gets a.</h5><img src="/images/Hungarian_Algorithm/example6.jpeg" >

<h5 id="As-for-4-because-c-is-assigned-and-we-cannot-asssign-other-vertices-for-1-2-3-It-reaches-the-end-of-the-algorithm-The-main-idea-is-to-reassign-some-vertices-to-others-and-see-if-it-can-increase-the-totally-number-of-matchings"><a href="#As-for-4-because-c-is-assigned-and-we-cannot-asssign-other-vertices-for-1-2-3-It-reaches-the-end-of-the-algorithm-The-main-idea-is-to-reassign-some-vertices-to-others-and-see-if-it-can-increase-the-totally-number-of-matchings" class="headerlink" title="As for 4, because c is assigned, and we cannot asssign other vertices for 1, 2, 3. It reaches the end of the algorithm. The main idea is to reassign some vertices to others and see if it can increase the totally number of matchings."></a>As for 4, because c is assigned, and we cannot asssign other vertices for 1, 2, 3. It reaches the end of the algorithm. The main idea is to reassign some vertices to others and see if it can increase the totally number of matchings.</h5><img src="/images/Hungarian_Algorithm/example7.jpeg" >


<h2 id="Hungarian-Tree"><a href="#Hungarian-Tree" class="headerlink" title="Hungarian Tree"></a>Hungarian Tree</h2><p>A hungarian tree usually got generated by BFS. we start from a<br>unmatched vertex, and traverse the graph though alternating path until it cannot be extended. Let us take a look at an example.<br><img src="/images/Hungarian_Algorithm/7.png" ><br>From Fig7, we can generate a BFS tree like Fig8.<br><img src="/images/Hungarian_Algorithm/8.png" ><br>For a graph like the left one in Fig9, we can<br><img src="/images/Hungarian_Algorithm/9.png" ></p>
<h2 id="Algorithm-implementation"><a href="#Algorithm-implementation" class="headerlink" title="Algorithm implementation."></a>Algorithm implementation.</h2><p>See the source code as below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int from;</span><br><span class="line">    int to;</span><br><span class="line">    int weight;</span><br><span class="line"></span><br><span class="line">    Edge(int f, int t, int w):from(f), to(t), weight(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; G[__maxNodes]; &#x2F;* G[i] 存储顶点 i 出发的边的编号 *&#x2F;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">typedef vector&lt;int&gt;::iterator iterator_t;</span><br><span class="line">int num_nodes;</span><br><span class="line">int num_left;</span><br><span class="line">int num_right;</span><br><span class="line">int num_edges;</span><br><span class="line"></span><br><span class="line">int matching[__maxNodes]; &#x2F;* 存储求解结果 *&#x2F;</span><br><span class="line">int check[__maxNodes];</span><br><span class="line"></span><br><span class="line">bool dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    for (iterator_t i &#x3D; G[u].begin(); i !&#x3D; G[u].end(); ++i) &#123; &#x2F;&#x2F; 对 u 的每个邻接点</span><br><span class="line">        int v &#x3D; edges[*i].to;</span><br><span class="line">        if (!check[v]) &#123;     &#x2F;&#x2F; 要求不在交替路中</span><br><span class="line">            check[v] &#x3D; true; &#x2F;&#x2F; 放入交替路</span><br><span class="line">            if (matching[v] &#x3D;&#x3D; -1 || dfs(matching[v])) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功</span><br><span class="line">                matching[v] &#x3D; u;</span><br><span class="line">                matching[u] &#x3D; v;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; &#x2F;&#x2F; 不存在增广路，返回失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int hungarian()</span><br><span class="line">&#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    memset(matching, -1, sizeof(matching));</span><br><span class="line">    for (int u&#x3D;0; u &lt; num_left; ++u) &#123;</span><br><span class="line">        if (matching[u] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            memset(check, 0, sizeof(check));</span><br><span class="line">            if (dfs(u))</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; Q;</span><br><span class="line">int prev[__maxNodes];</span><br><span class="line">int Hungarian()</span><br><span class="line">&#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    memset(matching, -1, sizeof(matching));</span><br><span class="line">    memset(check, -1, sizeof(check));</span><br><span class="line">    for (int i&#x3D;0; i&lt;num_left; ++i) &#123;</span><br><span class="line">        if (matching[i] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">            while (!Q.empty()) Q.pop();</span><br><span class="line">            Q.push(i);</span><br><span class="line">            prev[i] &#x3D; -1; &#x2F;&#x2F; 设 i 为路径起点</span><br><span class="line">            bool flag &#x3D; false; &#x2F;&#x2F; 尚未找到增广路</span><br><span class="line">            while (!Q.empty() &amp;&amp; !flag) &#123;</span><br><span class="line">                int u &#x3D; Q.front();</span><br><span class="line">                for (iterator_t ix &#x3D; G[u].begin(); ix !&#x3D; G[u].end() &amp;&amp; !flag; ++ix) &#123;</span><br><span class="line">                    int v &#x3D; edges[*ix].to;</span><br><span class="line">                    if (check[v] !&#x3D; i) &#123;</span><br><span class="line">                        check[v] &#x3D; i;</span><br><span class="line">                        Q.push(matching[v]);</span><br><span class="line">                        if (matching[v] &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 此点为匹配点</span><br><span class="line">                            prev[matching[v]] &#x3D; u;</span><br><span class="line">                        &#125; else &#123; &#x2F;&#x2F; 找到未匹配点，交替路变为增广路</span><br><span class="line">                            flag &#x3D; true;</span><br><span class="line">                            int d&#x3D;u, e&#x3D;v;</span><br><span class="line">                            while (d !&#x3D; -1) &#123;</span><br><span class="line">                                int t &#x3D; matching[d];</span><br><span class="line">                                matching[d] &#x3D; e;</span><br><span class="line">                                matching[e] &#x3D; d;</span><br><span class="line">                                d &#x3D; prev[d];</span><br><span class="line">                                e &#x3D; t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if (matching[i] !&#x3D; -1) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><ol>
<li><a href="https://www.renfei.org/blog/bipartite-matching.html" target="_blank" rel="noopener">https://www.renfei.org/blog/bipartite-matching.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/07/12/hungarian%20algorithm/" data-id="ckcjk3oak0000d3sj9d1ehtog" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Autonomous-Driving/" rel="tag">Autonomous Driving</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Radar/" rel="tag">Radar</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Sensor-Fusion/" rel="tag">Sensor Fusion</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Radar Tracker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/05/10/Radar%20Tracker/" class="article-date">
  <time datetime="2020-05-10T18:59:25.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Autonomous-Driving/">Autonomous Driving</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/05/10/Radar%20Tracker/">Radar Tracker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>A radar tracker is a component of a radar system, or an associated command and control (C2) system, that associates consecutive radar observations of the same target into tracks. It is particularly useful when the radar system is reporting data from several different targets or when it is necessary to combine the data from several different radars or other sensors.</p>
<p>A classical rotating air surveillance radar system detects target echoes against a background of noise. It reports these detections (known as “plots”) in polar coordinates representing the range and bearing of the target. In addition, noise in the radar receiver will occasionally exceed the detection threshold of the radar’s Constant false alarm rate detector and be incorrectly reported as targets (known as false alarms). The role of the radar tracker is to monitor consecutive updates from the radar system (which typically occur once every few seconds, as the antenna rotates) and to determine those sequences of plots belonging to the same target, whilst rejecting any plots believed to be false alarms. In addition, the radar tracker is able to use the sequence of plots to estimate the current speed and heading of the target. When several targets are present, the radar tracker aims to provide one track for each target, with the track history often being used to indicate where the target has come from.</p>
<h2 id="A-radar-track-will-typically-contain-the-following-information"><a href="#A-radar-track-will-typically-contain-the-following-information" class="headerlink" title="A radar track will typically contain the following information:"></a>A radar track will typically contain the following information:</h2><ol>
<li>Position (in two or three dimensions)</li>
<li>Heading</li>
<li>Speed</li>
<li>Unique track number</li>
<li>status</li>
<li>Age – used in tracker initiation and maintenance</li>
</ol>
<p>I would believe in the future, when 4D radar becomes popular, category of the object will definitely become an importannt information which can be provided by radar. They just the dense radar point cloud to train the neural network to classify the object type. Currently, the automotive radar only provides a parse reflection data point instead of a point cloud.</p>
<h2 id="How-to-implement-radar-tracker"><a href="#How-to-implement-radar-tracker" class="headerlink" title="How to implement radar tracker"></a>How to implement radar tracker</h2><h5 id="1-Plot-to-track-association-Associate-a-radar-plot-with-an-existing-track"><a href="#1-Plot-to-track-association-Associate-a-radar-plot-with-an-existing-track" class="headerlink" title="1. Plot to track association: Associate a radar plot with an existing track"></a>1. Plot to track association: Associate a radar plot with an existing track</h5><h5 id="2-Track-smoothing-Update-the-track-with-this-latest-plot"><a href="#2-Track-smoothing-Update-the-track-with-this-latest-plot" class="headerlink" title="2. Track smoothing: Update the track with this latest plot"></a>2. Track smoothing: Update the track with this latest plot</h5><h5 id="3-Track-initiation-Spawn-new-tracks-with-any-plots-that-are-not-associated-with-existing-tracks"><a href="#3-Track-initiation-Spawn-new-tracks-with-any-plots-that-are-not-associated-with-existing-tracks" class="headerlink" title="3. Track initiation: Spawn new tracks with any plots that are not associated with existing tracks"></a>3. Track initiation: Spawn new tracks with any plots that are not associated with existing tracks</h5><h5 id="4-Track-maintenance-Delete-any-tracks-that-have-not-been-updated-or-predict-their-new-location-based-on-the-previous-heading-and-speed"><a href="#4-Track-maintenance-Delete-any-tracks-that-have-not-been-updated-or-predict-their-new-location-based-on-the-previous-heading-and-speed" class="headerlink" title="4. Track maintenance: Delete any tracks that have not been updated, or predict their new location based on the previous heading and speed"></a>4. Track maintenance: Delete any tracks that have not been updated, or predict their new location based on the previous heading and speed</h5><h2 id="Track-association"><a href="#Track-association" class="headerlink" title="Track association"></a>Track association</h2><p>Perhaps the most important step is the updating of tracks with new plots. All trackers will implicitly or explicitly take account of a number of factors during this stage, including:</p>
<ol>
<li>a model for how the radar measurements are related to the target coordinates</li>
<li>the errors on the radar measurements</li>
<li>a model of the target movement</li>
<li>errors in the model of the target movement</li>
</ol>
<p>When I got the time, I will post an article to update all the information above.</p>
<p>we can first take a very light sip on the first topic – how the radar measurements are related to the target coordinates.<br>A very famous clustering method in machine learning area – Kmeans clustering.</p>
<h3 id="K-means-clustering"><a href="#K-means-clustering" class="headerlink" title="K means clustering"></a>K means clustering</h3><p>What is K means clustering ?<br>It is an unsupervised machine learning method used for clustering. It aims to partition n observations into k clusters in which each observation belongs to the cluster with the centroid. So the process of radar data point association is an X-means clustering. The reason I used X here is because we don`t know how many clusters will be there finally. But for K means clustering, we have to first define that there will be and only will be K clusters.</p>
<p>Here are the steps for k means clustering.</p>
<ol>
<li>Randomly generate k data points as centroids, these k data points must be within the range of the whole data set. </li>
<li>Pick a data point from the data set, calculate the Euclidean distance between the data point and all the centroids, assign the data point to the one with  the smallest Euclidean distance.</li>
<li>Repeat step 2 for all the data points.</li>
<li>We will get k clusters now, recalculate the centroids. Repeat step 2 and step 3.</li>
<li>When the current centroids and previous centroids are close enough, end the process.</li>
</ol>
<img src="/images/Radar_Tracker/k_means.webp" width="400" hegiht="400">

<h5 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">def kMeans(data,k&#x3D;2):</span><br><span class="line">    def _distance(p1,p2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        In order to speed up, actually we don&#96;t necessarily to use Euclidean distance, we just get the square of Euclidean distance will be good enough, it can save a lot of computing power.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return np.sum((p1-p2)**2)</span><br><span class="line"></span><br><span class="line">    def get_centroid(data,k):</span><br><span class="line">        &quot;&quot;&quot;Generate k center within the range of data set.&quot;&quot;&quot;</span><br><span class="line">        n &#x3D; data.shape[1] # features</span><br><span class="line">        centroids &#x3D; np.zeros((k,n)) # init with (0,0)....</span><br><span class="line">        for i in range(n):</span><br><span class="line">            dmin, dmax &#x3D; np.min(data[:,i]), np.max(data[:,i])</span><br><span class="line">            centroids[:,i] &#x3D; dmin + (dmax - dmin) * np.random.rand(k)</span><br><span class="line">        return centroids</span><br><span class="line">    </span><br><span class="line">    def is_converged(centroid1, centroids):</span><br><span class="line">         set1 &#x3D; set([tuple(c) for c in centroid1])</span><br><span class="line">         set2 &#x3D; set([tuple(c) for c in centroid2])</span><br><span class="line">         return (set1 &#x3D;&#x3D; set2)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    n &#x3D; data.shape[0] # number of entries</span><br><span class="line">    centroids &#x3D; _rand_center(data,k)</span><br><span class="line">    label &#x3D; np.zeros(n,dtype&#x3D;np.int) # track the nearest centroid</span><br><span class="line">    assement &#x3D; np.zeros(n) # for the assement of our model</span><br><span class="line">    converged &#x3D; False</span><br><span class="line">    </span><br><span class="line">    while not converged:</span><br><span class="line">        old_centroids &#x3D; np.copy(centroids)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            # determine the nearest centroid and track it with label</span><br><span class="line">            min_dist, min_index &#x3D; np.inf, -1</span><br><span class="line">            for j in range(k):</span><br><span class="line">                dist &#x3D; _distance(data[i],centroids[j])</span><br><span class="line">                if dist &lt; min_dist:</span><br><span class="line">                    min_dist, min_index &#x3D; dist, j</span><br><span class="line">                    label[i] &#x3D; j</span><br><span class="line">            assement[i] &#x3D; _distance(data[i],centroids[label[i]])**2</span><br><span class="line">        </span><br><span class="line">        # update centroid</span><br><span class="line">        for m in range(k):</span><br><span class="line">            centroids[m] &#x3D; np.mean(data[label&#x3D;&#x3D;m],axis&#x3D;0)</span><br><span class="line">        converged &#x3D; is_converged(old_centroids,centroids)    </span><br><span class="line">    return centroids, label, np.sum(assement)</span><br></pre></td></tr></table></figure>
<p>An obvious weakness of K means clustering is that it could converge to local optimal instead of global optimal. So we could run the algorithm multiple times in order to get a better result.</p>
<h2 id="Tracking-smoothing"><a href="#Tracking-smoothing" class="headerlink" title="Tracking smoothing:"></a>Tracking smoothing:</h2><ol>
<li>Alpha-beta tracker</li>
<li>Kalman filter</li>
<li>Multiple hypothesis tracker(MHT)</li>
<li>Interacting multiple model</li>
</ol>
<p>We will talk more about Kalman filter and Multiple hypothesis tracker in the future. Because these two are widely used in the industry.</p>
<h2 id="Tracking-initiation"><a href="#Tracking-initiation" class="headerlink" title="Tracking initiation:"></a>Tracking initiation:</h2><p>Track initiation is the process of creating a new radar track from unassociated radar plots. When the radar tracker is first switched on, all of the initial radar plots are used to initialize new tracks. Once the radar tracker is running, only those plots are used to create a new track that couldn’t be used to update an existing one.</p>
<p>Typically a new track is given the status of tentative until plots from subsequent radar updates have been successfully associated with the new track. Tentative tracks are not shown to the operator and so they provide a means of preventing false tracks from appearing on the screen – at the expense of some delay in the first reporting of a track.</p>
<p>Once several updates have been received, the track is confirmed and displayed to the operator. The most common criterion for promoting a tentative track to a confirmed track is the “M-of-N rule”, which states that during the last N radar updates, at least M plots must have been associated with the tentative track – with M=3 and N=5 being typical values. More sophisticated approaches may use a statistical approach in which a track becomes confirmed when, for instance, its covariance matrix falls to a given size.</p>
<p>A clutter map may be used to prevent track initiation in areas of strong clutter echoes not suppressed by the Doppler processing. The clutter map may also keep track of large bird echoes, so as to not be reinitiating track on them, repeatedly. Track initiation in a dense clutter environment can be quite demanding on computer software and hardware resources.</p>
<h2 id="Tracker-maintenance"><a href="#Tracker-maintenance" class="headerlink" title="Tracker maintenance:"></a>Tracker maintenance:</h2><p>Track maintenance is the process in which a decision is made about whether to end the life of a track. If a track was not associated with a plot during the plot to track association phase, then there is a chance that the target may no longer exist (for instance, an aircraft may have landed or flown out of radar cover).</p>
<p>Alternatively, however, there is a chance that the radar may have just failed to see the target at that update, but will find it again on the next update. Common approaches to deciding on whether to terminate a track include:</p>
<ol>
<li>If the target was not seen for the past M consecutive update opportunities (typically M=3 or so)</li>
<li>If the target was not seen for the past M out of N most recent update opportunities</li>
<li>If the target’s track uncertainty (covariance matrix) has grown beyond a certain threshold.</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Radar_tracker" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radar_tracker</a></li>
<li><a href="https://www.advsolned.com/example_radar_tracking.html" target="_blank" rel="noopener">https://www.advsolned.com/example_radar_tracking.html</a></li>
<li><a href="https://github.com/USNavalResearchLaboratory/TrackerComponentLibrary">https://github.com/USNavalResearchLaboratory/TrackerComponentLibrary</a></li>
<li><a href="https://www.blighter.com/products/blightertrack/" target="_blank" rel="noopener">https://www.blighter.com/products/blightertrack/</a></li>
<li><a href="https://www.radartutorial.eu/10.processing/sp22.en.html" target="_blank" rel="noopener">https://www.radartutorial.eu/10.processing/sp22.en.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/05/10/Radar%20Tracker/" data-id="cka1e8vhi0001t8sjggmpfbpz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Autonomous-Driving/" rel="tag">Autonomous Driving</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Radar/" rel="tag">Radar</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Deep Learning Bag of Freebies" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/05/03/Deep%20Learning%20Bag%20of%20Freebies/" class="article-date">
  <time datetime="2020-05-04T00:34:35.176Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Machine-Learning/">Machine Learning</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/05/03/Deep%20Learning%20Bag%20of%20Freebies/">Deep Learning Bag of Freebies</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This artical was original from <a href="https://medium.com/@sahiluppal/bag-of-freebies-95092859d279" target="_blank" rel="noopener">https://medium.com/@sahiluppal/bag-of-freebies-95092859d279</a><br>The author owns the copyright of the article.</p>
<p>A list of techniques used in combination to improve a variety of computer vision task<br><img src="/images/Deep Learning/Bag of Freebies/SOTA_vs_Bag_Of_Freebies.png" width="800" hegiht="600"><br>Object detection is, no doubt, one of the most fundamental applications in computer vision. Latest state-of-the-art detectors (including single-stage like YOLO or multiple-stage like RCNN [and derivatives]) are based on image classification backbone networks e.g., VGG, ResNet etc.<br>There are multiple techniques “collectively known as Bag of Freebies”, which can be used in combination to boost the performance of all popular object detection networks without introducing extra computational cost during inference.<br>Why Bag of Freebies got attention?<br>Usually, object detectors are trained offline. Therefore, researchers always like to take advantage and develop better training methods which can make the object detector receive better accuracy without increasing inference cost. These methods only changes the training strategy or what we can say training cost. You can think bag of freebies as a pipeline of data augmentation techniques. The sole purpose of data augmentation is to increase the variability of the input images, so that the designed object detection model has higher robustness to the images obtained from different environments.<br>In general, photometric distortions and geometric distortions are two commonly used data augmentation method and they definitely benefit the object detection tasks. In photometric distortions, we adjust the brightness, contrast, hue, saturation and noise of an image. For geometric distortions, we add random scaling, cropping, flipping, and rotating. In addition, some researchers engaged in data augmentation put their emphasis on simulating object occlusion issues (when an object covers a portion of another object.).<br>These freebies are all training time modifications, and therefore, only affect model weights without changing the network structure and have achieved good results in image classification and object detection methods.<br>Bag of Freebies<br>In this section, we enlist an image mix-up method for object detection. We will introduce data processing and training schedule designed to improve performance of object detection models.</p>
<h2 id="1-Image-Mix-up-for-Object-Detection"><a href="#1-Image-Mix-up-for-Object-Detection" class="headerlink" title="1. Image Mix-up for Object Detection"></a>1. Image Mix-up for Object Detection</h2><p>The key idea of mix-up in image classification task is to linearly mixing up pixels from one image to another image in a specific ratio where both images belong to the same training dataset. At the same time, one-hot encoded labels of both images are also mixed using the same ratio. The ratio in mix-up algorithm is drawn from a distribution called beta distribution written as B(alpha, beta).<br><img src="/images/Deep Learning/Bag of Freebies/mix_up1.png" width="800" hegiht="600"><br>//small<br>Mix-up visualization of image classification with typical mix-up ratio of 0.1: 0.9. Two images are mixed uniformly across all pixels, and image labels are weighted summation of original one-hot label vector.<br>In this example, a bird image is mixed with a wall clock image in a typical 0.1: 0.9 ratio and so as their one-hot encoded labels.<br><img src="/images/Deep Learning/Bag of Freebies/mix_up2.png" width="800" hegiht="600"><br>//small<br>Geometry preserved alignment of mixed images for object detection. Image pixels are mixed up, object labels are merged as a new array.<br>In this example, both images are merged along with their ground truth object coordinates as a new array while preserving their geometry.<br>To verify mix-up designed for object detection, while choosing a beta distribution with alpha, beta are both at least 1,we experimentally test mix-up ratio distributions using the YOLOv3 network on Pascal VOC dataset. Below Table shows the actual improvements by adopting detection mix-up ratios sampled by different beta distributions. Beta distribution with alpha and beta both equal to 1.5 is marginally better than 1.0 equivalent to uniform distribution). It increases the mean average precision by almost 3% from the baseline.<br><img src="/images/Deep Learning/Bag of Freebies/mix_up3.png" width="800" hegiht="600"><br>//small<br>Effect of various mix-up approaches, validated with YOLO3 on Pascal VOC 2007 test set. Weighted loss indicates the overall loss is the summation of multiple objects with ratio 0 to 1 according to image blending ratio they belong to in the original training images.<br>In contrast, Rosenfeld conducted a series of experiments name as “Elephant in the room”, where an elephant image patch is randomly placed on a natural image, then this adversarial image is used to challenge existing object detection models. The results indicate that existing object detection models are prune to such attack and show weakness to detect such transplanted objects. Researchers followed the same experiments by sliding an elephant image patch through an indoor room image, trained two YOLOv3 models on COCO 2017 dataset with one mix-up approach and other isn’t. They can observe that vanilla model trained without mix-up approach is struggling to detect “elephant in the room” due to heavy occlusion and lack of context because it’s rare to capture an elephant in a kitchen, and model trained with mix approach is more robust. In addition, they also noticed that mix model is more humble. less confident and generates lower scores for object on average. However, this behavior does not affect evaluation results as shown.<br><img src="/images/Deep Learning/Bag of Freebies/mix_up4.png" width="800" hegiht="600"><br>//small<br>Elephant in the room example. Model trained with geometry preserved mixup (bottom) is more robust against alien objects compared to baseline (top)<br>It was obvious that model trained with visually coherent mixup is more robust (94.12 vs 42.95) to detect elephant in indoor scene even though it is very rare in natural images. And even mix-up model easily handles occlusion as you can see in bottom row. The mix-up model receives more challenges during training therefore is significantly better than vanilla model in handling unprecedented scenes and very crowded object groups.<br><img src="/images/Deep Learning/Bag of Freebies/mix_up5.png" width="800" hegiht="600"><br>/small<br>Statistics of detection results affected by elephant in the room. ”Recall of elephant” is the recall of sliding elephant in all generated frames, indicating how robust the model handles objects in unseen context.</p>
<h2 id="2-Classification-Head-Label-Smoothing"><a href="#2-Classification-Head-Label-Smoothing" class="headerlink" title="2. Classification Head Label Smoothing"></a>2. Classification Head Label Smoothing</h2><p>Label smoothing is a loss function modification that has been shown to be very effective for training deep learning networks. Label smoothing improves accuracy in image classification, translation, and even speech recognition. The simple explanation of how it works is that it changes the training target for the neural nets from a hard ‘1’ to ‘1-label smoothing adjustment’, meaning the neural nets is trained to be a bit less confident of it’s answers.<br>Example: assume we want to classify images into dogs and cats. If we see a photo of a dog, we train the neural nets (via cross entropy loss) to move towards a 1 for dog, and 0 for cat. And if a cat, the reverse where we train towards 1 for cat, 0 for dog. In other words, a binary or “hard’ answer.<br>However, neural nets have a bad habit of becoming ‘over-confident’ in their predictions during training, and this can reduce their ability to generalize and thus perform as well on new, unseen future data. In addition, large datasets can often include incorrectly labeled data, meaning inherently the neural nets should be a bit skeptical of the ‘correct answer’ to reduce extreme modeling around some degree of bad answers.<br>Thus, what label smoothing does is force the neural nets to be less confident in it’s answers by training it to move towards the ‘1-adjustment’ target, and then dividing the adjustment amount over the remaining classes…. rather than simply a hard 1.<br>For our binary dog/cat example, label smoothing of .1 means the target answer would be .90 (90% confident) it’s a dog for a dog image, and .10 (10% confident) it’s a cat, rather than the previous move towards 1 or 0. By being a bit less certain, it acts as a form of regularization and improves it’s ability to perform better on new data.<br>Label smoothing’s affect on Neural Networks: Now we get to the heart of the paper, which shows visually how label smoothing affects the NN’s classification processing.<br>ResNet classifying “airplane, automobile and bird” during training and validation.<br><img src="/images/Deep Learning/Bag of Freebies/Classification Head Label Smoothing1.png" width="800" hegiht="600"><br>// small<br>ResNet training for classifying 3 image categories…note the tremendous difference in cluster tightness<br><img src="/images/Deep Learning/Bag of Freebies/Classification Head Label Smoothing2.png" width="800" hegiht="600"><br>// small<br>ResNet validation results. Label smoothing increased the final accuracy. Note that while the label smoothing drives activations to tight clusters in training, in validation it spreads around the center and leverages a full range of confidences with it’s predictions.</p>
<p>As the images visually show, label smoothing produces tighter clustering and greater separation between categories for the final activations.<br>This is a primary reason why label smoothing produces more regularized and robust neural networks, that importantly tend to generalize better on future data. However, there’s an additional beneficial effect than just better activation centering.</p>
<h2 id="3-Data-Preprocessing"><a href="#3-Data-Preprocessing" class="headerlink" title="3. Data Preprocessing"></a>3. Data Preprocessing</h2><p>In image classification domain, usually neural networks are extremely tolerant to image geometrical transformation. It is actually encouraged to randomly augment the images e.g. randomly flip, rotate and crop images in order to improve generalization accuracy and avoid overfitting.<br>In terms of types of detection networks, there are two type of pipelines for generalizing final predictions. First is single stage detector networks, where final outputs are generated directly from feature map from the CNN backbone, for example SSD(single shot detector) and YOLO networks. The second type is multi-stage proposal and sampling based approaches, following Fast-RCNN, where a certain number of regions are sampled from a large pool of generated ROIs, where final outputs are generated by applying cropping based techniques to the feature maps from CNN backbone.<br>Since multi-stage networks already applies cropping based techniques, they doesn’t need their input to be augmented with random cropping and many more extensive geometric augmentations. But single stage detectors can reproduce highly appealing results if augmentation is applied to the input images. This is the major difference between one-stage and so called multi-stage object detection data pipelines.</p>
<h2 id="4-Training-Schedule-Revamping"><a href="#4-Training-Schedule-Revamping" class="headerlink" title="4. Training Schedule Revamping"></a>4. Training Schedule Revamping</h2><p>During training, the learning rate usually starts with a relatively big number and gradually becomes smaller throughout the training process. For instance the default learning rate schedule for Faster-RCNN is to reduce learning rate by ratio 0.1 to 60k iterations. Similarly, YOLOv3 uses same ratio 0.1 to reduce learning rate at 40k and 45k iterations. As this is a sharp learning rate transition which may cause the optimizer to re-stabilize the learning momentum in the next few iterations.<br>In contrast a smoother cosine learning rate adjustment can be used. Cosine schedules scales the learning rate according to the value of cosine function on 0 to pi.<br><img src="/images/Deep Learning/Bag of Freebies/Training Schedule Revamping1.png" width="800" hegiht="600"><br>Visualization of learning rate scheduling with warmup enabled for YOLOv3 training on Pascal VOC. (a): cosine and step schedules for batch size 64. (b): Validation mAP comparison curves using step and cosine learning schedule.<br>Warmup learning rate is another common strategy to avoid gradient explosion during the initial training iterations. Training with cosine schedule and proper warmup lead to better validation accuracy as shown in the figure.</p>
<h2 id="5-Synchronized-Batch-Normalization-and-Random-Shape-Input"><a href="#5-Synchronized-Batch-Normalization-and-Random-Shape-Input" class="headerlink" title="5. Synchronized Batch Normalization and Random Shape Input"></a>5. Synchronized Batch Normalization and Random Shape Input</h2><p>Neural networks are compute intensive but are highly parallelizable. This leads us to the need of computation environments to equip multiple devices (GPUs) to accelerate training. Batch Normalization helps us to train input data in chunks while reducing sensitivity towards hyperparameters. Although the typical implementation of Batch Normalization working on multiple devices (GPUs) is fast, but experiments suggests that reducing size of batch size on multiple devices causing slightly different statistics during computation, which potentially degraded performance. This is not a significant issue in some standard vision tasks such as ImageNet classification (as the batch size per device is usually large enough to obtain good statistics). However, it hurts the performance in some tasks with a small batch size (e.g., 1 per GPU).<br>Natural training images come in various shapes. To fit memory limitation and allow simpler batching, many single-stage object detection networks are trained with fixed shapes. To reduce risk of overfitting and to improve generalization of network prediction, researchers follow YOLOv3’s official implementation details and used a mini-batch of N training images and resized to N x 3 x H x W, where H and W are multipliers of network stride. For example YOLOv3 use H = W = {320,352,384,416,448,480,512,544,576,608} for training using VGG as CNN backbone whose stride is 32.<br>Results<br>Stacking all these tweaks for object detection, researchers sticked to major frameworks YOLOv3(representing single-stage pipelines) which is famous for its efficiency and good accuracy and Faster-RCNN(representing multi-stage pipelines) which is one of the most adopted detection framework and foundation of many others variant.<br>YOLOv3<br><img src="/images/Deep Learning/Bag of Freebies/Results1.png" width="800" hegiht="600"><br>//small<br>-&gt;COCO 80 category AP analysis with YOLOv3 .Red lines indicate performance gain using bag of freebies, while blue lines indicate performance drop.&lt;-<br>As we can see in the above representation, YOLOv3 is trained on COCO dataset on which have almost 80 categories. while using the above tweaks researchers can claim the performance gain (shown in red) and we can also see some performance drop (shown in blue). But overall YOLOv3 gets 3.43% performance gain on AP.<br><img src="/images/Deep Learning/Bag of Freebies/Results2.png" width="800" hegiht="600"><br>//small<br>Incremental trick validation results of YOLOv3, evaluatedat416×416on Pascal VOC 2007 test set.<br>Faster-RCNN<br><img src="/images/Deep Learning/Bag of Freebies/Results3.png" width="800" hegiht="600"><br>// small<br>COCO 80 category AP analysis with Faster-RCNN resnet50. Red lines indicate performance gain using bag of freebies, while blue lines indicate performance drop.<br>Similarly in the above representation, Faster-RCNN with ResNet50 CNN backbone also trained on COCO dataset. while using the above tweaks researchers can claim the performance gain (shown in red) and we can also see some performance drop (shown in blue). But overall Faster-RCNN gets 3.55% performance gain on AP.<br><img src="/images/Deep Learning/Bag of Freebies/Results4.png" width="800" hegiht="600"></p>
<p>Conclusion<br>In this article, we showed that how bag of training enhancements significantly improves model performances while introducing zero overhead to the inference environment. Empirical experiments of YOLOv3 and Faster-RCNN on Pascal VOC and COCO datasets show that the bag of tricks are consistently improving object detection models. By stacking all these tweaks, we observe no signs of degradation of any level and suggest a wider adoption to future object detection pipelines. These freebies are all training time modifications and therefore only affect model weights without increasing inference time or change of network structures.<br>References<br>[1] Bag of Freebies for Training Object Detection Neural Networks. <a href="https://arxiv.org/pdf/1902.04103.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1902.04103.pdf</a><br>[2] YOLOv4: Optimal Speed and Accuracy of Object Detection. <a href="https://arxiv.org/pdf/2004.10934.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2004.10934.pdf</a><br>[3] Gluoncv toolkit. <a href="https://github.com/dmlc/gluon-cv">https://github.com/dmlc/gluon-cv</a><br>[4] Redmon and A. Farhadi. Yolov3: An incremental improvement. <a href="https://arxiv.org/abs/1804.02767" target="_blank" rel="noopener">https://arxiv.org/abs/1804.02767</a><br>[5] Label Smoothing &amp; Deep Learning: Google Brain explains why it works and when to use (SOTA tips). <a href="https://medium.com/@lessw/label-smoothing-deep-learning-google-brain-explains-why-it-works-and-when-to-use-sota-tips-977733ef020" target="_blank" rel="noopener">https://medium.com/@lessw/label-smoothing-deep-learning-google-brain-explains-why-it-works-and-when-to-use-sota-tips-977733ef020</a><br>[6] Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks. <a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">https://arxiv.org/abs/1506.01497</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/05/03/Deep%20Learning%20Bag%20of%20Freebies/" data-id="ck9rr6dgu0000xosj5ujlf86j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Deep-Learning/" rel="tag">Deep Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Machine-Learning/" rel="tag">Machine Learning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Bitonic_Sort" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/04/26/Bitonic_Sort/" class="article-date">
  <time datetime="2020-04-26T22:59:25.000Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Parallel-Computing/">Parallel Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/04/26/Bitonic_Sort/">双调排序 Bitonic Sort</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>双调排序是并行计算里面一个非常重要而且常见的应用。其思想跟归并排序一样，都是用了分治的思想。<br>为什么它叫做双调排序呢？因为Bitonic Sort 会先将一个数列排序成为前半段单调递增，后半段单调递减<br>的这么一个序列（中间过渡使用），这样一个前半段单调递增，后半段单调递减的序列，我们又把它叫做Bitonic sequence（双调序列）。</p>
<p>具体实现Bitonic Sort的操作如下：<br>下图所示是一个Bitonic Sort的示意图：</p>
<img src="/images/Bitonic_Sort/BitonicSort1.svg.png" width="800" hegiht="600">



<ol>
<li>先将任意序列变为双调序列。<br>假设有一个长为n的序列，n = 2 ^ k，那么，我们将其两两分组，假设n = 16，如下图所示，为了便于理解，我们假设数组从nums[1] 到nums[16]（这一点跟C/C++/Python 数组的起始index不同，只是为了方便）</li>
</ol>
<p>我们先进行第一步，那么一共有8组，所有奇数组的数字，比如 nums[1] 和 nums[2]（第一组）, 又或者 nums[5] 和nums[6]（第三组）等等，进行两两比较，比较的结果是，小的在前，大的在后。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if nums[1] &gt; nums[2]:</span><br><span class="line">    nums[1], nums[2] &#x3D; nums[2], nums[1]</span><br></pre></td></tr></table></figure>
<p>同理，所有偶数组的数字，比如nums[3] 和 nums[4]，他们比较的结果相反，大的在上，小的在下。如此一来，nums[1], nums[2], nums[3],nums[4] 这4个数字就形成了一个bitonic sequence。</p>
<p>第二步，此时，我们将前面一步的8组结果，进行两两合并，成为4组数据，每一组里面呢，第一个数字跟第三个数字比较，第二个数字跟第四个数字比。如果是奇数组，那么依然是大的放到后面，小的数字放到前面。偶数组，大的在前，小的在后。<br>这样还不算完，第二步分成了两个部分，比较完了，nums[1]和nums[3]，nums[2]和nums[4]，我们还需要将nums[1]和nums[2]，nums[3]和nums[4] 再次进行小组比较。如此一来，第一组（nums[1]，nums[2],nums[3],nums[4]就成为了一个生序序列，而第二组成为了一个降序序列。</p>
<p>第三步，与前一步雷同，需要将4组数据进行两两合并，此时只有两个大组。</p>
<p>第四步，与前一步依然雷同，只是由于只有一组数据了，我们所做的，就是将一大组bitonic sequence进行梳理，整理成为一个升序序列。</p>
<p>Bitonic sort 的Python实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def bitonic_sort(up: bool, x: Sequence[int]) -&gt; List[int]:</span><br><span class="line">    &quot;&quot;&quot;Bitonic sort.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">      up: ascending if &#39;&#39;up&#39;&#39; is true, and decreasing otherwise.</span><br><span class="line">      x: A sequence of integers.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">      Sorted sequence of integers.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if len(x) &lt;&#x3D; 1:</span><br><span class="line">        return x</span><br><span class="line">    else: </span><br><span class="line">        first &#x3D; bitonic_sort(True, x[:len(x) &#x2F;&#x2F; 2])</span><br><span class="line">        second &#x3D; bitonic_sort(False, x[len(x) &#x2F;&#x2F; 2:])</span><br><span class="line">        return bitonic_merge(up, first + second)</span><br><span class="line"></span><br><span class="line">def bitonic_merge(up: bool, x) -&gt; List[int]: </span><br><span class="line">    # Assume input x is bitonic, and sorted list is returned </span><br><span class="line">    if len(x) &#x3D;&#x3D; 1:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        bitonic_compare(up, x)</span><br><span class="line">        first &#x3D; bitonic_merge(up, x[:len(x) &#x2F;&#x2F; 2])</span><br><span class="line">        second &#x3D; bitonic_merge(up, x[len(x) &#x2F;&#x2F; 2:])</span><br><span class="line">        return first + second</span><br><span class="line"></span><br><span class="line">def bitonic_compare(up: bool, x) -&gt; None:</span><br><span class="line">    dist &#x3D; len(x) &#x2F;&#x2F; 2</span><br><span class="line">    for i in range(dist):</span><br><span class="line">        if (x[i] &gt; x[i + dist]) &#x3D;&#x3D; up:</span><br><span class="line">            x[i], x[i + dist] &#x3D; x[i + dist], x[i]  # Swap</span><br></pre></td></tr></table></figure>


<p>那么，Bitonic Sort 的时间复杂度和空间复杂度分别都是什么样的呢？<br>假设S(n)是sort n个数字所需要的比较的次数，M(n)是合并n个数字所需要的比较的次数。<br>那么我们有，S(n) = 2*S(n) + M(n), M(n) = 2 * M(n) + n / 2，解出来可以得到<br>M(n) = O(nlog(n))<br>S(n) = O(n(log(n))^2)<br>粗一看，时间比merge sort或者quick sort还要慢，但是我们必须要搞明白，我们可以create n个thread<br>这样时间复杂度就只有O((log(n))^2) 了。<br>因为总共需要O(n(log(n))^2)次比较，每次比较都需要新开内存，所以space complexity是O(n(log(n))^2)。</p>
<p>如果大家感兴趣的，也可以看一看bitonic sort 在cuda里的实现，上述代码只是简单的讲一下bitonic实现的原理，<br>但是实际上并不会比merge sort或者quick sort更快，因为我们既没有用到多线程，也没有使用GPU。</p>
<p>CUDA 实现Bitnoic Sort: <a href="https://gist.github.com/mre/1392067" target="_blank" rel="noopener">https://gist.github.com/mre/1392067</a></p>
<p>MPI 实现Bitnoic Sort: <a href="https://github.com/orestisfl/mpi_bitonic_sort">https://github.com/orestisfl/mpi_bitonic_sort</a></p>
<h2 id="reference："><a href="#reference：" class="headerlink" title="reference："></a>reference：</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Bitonic_sorter" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bitonic_sorter</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/04/26/Bitonic_Sort/" data-id="ck8xzbmhg0000m1sj43n5dxtg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Parallel-Computing/" rel="tag">Parallel Computing</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Parallel Computing 2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/29/Parallel%20Computing%202/" class="article-date">
  <time datetime="2020-03-29T16:48:25.000Z" itemprop="datePublished">2020-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Parallel-Computing/">Parallel Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/29/Parallel%20Computing%202/">Parallel Computing 2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SCAN-and-Reduce"><a href="#SCAN-and-Reduce" class="headerlink" title="SCAN and Reduce"></a>SCAN and Reduce</h1><h3 id="SCAN-application-—-SCAN-in-quicksort"><a href="#SCAN-application-—-SCAN-in-quicksort" class="headerlink" title="SCAN application — SCAN in quicksort"></a>SCAN application — SCAN in quicksort</h3><p>Let`s say if we have an array A[0:11] = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9]<br>How do we make use parallel computing to do the quick sort here.<br>In order to do a quick sort, we should first find a number as a pivot point.<br>Let take the A[9] = 3 as the pivot point.<br>[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9]<br>                            ^<br>                            |<br>                           pivot<br>so we can load each number into a memory cell, and compare all the number with A[9].<br>We create an array to store the result – if the number if greater than the pivot number, we assign it to 0, otherwise 1.</p>
<p>so we have<br>original array =   [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9]<br>A[:] &lt;= pivot ?    [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]<br>scan the array<br>above we will have:[0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]</p>
<p>we can easily get the L[0:4] = [3, 1, 1, 2, 3]</p>
<pre><code>Psedo code:
1. first we compute the flags, 
2. do a scan to get the indices
3. </code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/29/Parallel%20Computing%202/" data-id="ck8bu1s5w0001shsj8f8rd4w8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Parallel-Computing/" rel="tag">Parallel Computing</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Multi-Threading in Python" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/28/Multi-Threading%20in%20Python/" class="article-date">
  <time datetime="2020-03-29T03:48:25.000Z" itemprop="datePublished">2020-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Parallel-Computing/">Parallel Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/28/Multi-Threading%20in%20Python/">Multi Threading in Python</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This article will introduce the most basic 5 different multi-threading methods implementation in Python. We will use a very simple example to show how to make use of these 5 different methods to solve a problem.</p>
<h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><p>Barrier objects in python are used to wait for a fixed number of thread to complete execution before any particular thread can proceed forward with the execution of the program. Each thread calls wait() function upon reaching the barrier. The barrier is responsible for keeping track of the number of wait() calls. If this number goes beyond the number of threads for which the barrier was initialized with, then the barrier gives a way to the waiting threads to proceed on with the execution. All the threads at this point of execution, are simultaneously released.</p>
<p>There are several main methods available from this object:</p>
<h5 id="parties"><a href="#parties" class="headerlink" title="parties()"></a>parties()</h5><p>A number of threads required to reach the common barrier point.</p>
<h4 id="n-waiting"><a href="#n-waiting" class="headerlink" title="n_waiting()"></a>n_waiting()</h4><p>Number of threads waiting in the common barrier point</p>
<h5 id="broken"><a href="#broken" class="headerlink" title="broken()"></a>broken()</h5><p>A boolean value, True- if the barrier is in the broken state else False.<br>####wait( timeout = None)<br>Wait until notified or a timeout occurs. If the calling thread has not acquired the lock when this method is called, a runtime error is raised.<br>This method releases the underlying lock and then blocks until it is awakened by a notify() or notify_all() method call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns.<br>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</p>
<h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h5><p>Set or return the barrier to the default state .i.e. empty state. And threads waiting on it will receive the BrokenBarrierError.</p>
<h5 id="bort"><a href="#bort" class="headerlink" title="bort()"></a>bort()</h5><p>This will put the barrier into a broken state. This causes all the active threads or any future calls to wait() to fail with the BrokenBarrierError.<br>Here is a program to show how barrier works in python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import threading </span><br><span class="line">  </span><br><span class="line">barrier &#x3D; threading.Barrier(3) </span><br><span class="line">  </span><br><span class="line">class thread(threading.Thread): </span><br><span class="line">    def __init__(self, thread_ID): </span><br><span class="line">        threading.Thread.__init__(self) </span><br><span class="line">        self.thread_ID &#x3D; thread_ID </span><br><span class="line">    def run(self): </span><br><span class="line">        print(str(self.thread_ID) + &quot;\n&quot;) </span><br><span class="line">        print(&quot;Parties &#x3D; &quot; + str(barrier.parties) + &quot;\n&quot;) </span><br><span class="line">        print(&quot;n_waiting &#x3D; &quot; + str(barrier.n_waiting) + &quot;\n&quot;) </span><br><span class="line">        barrier.wait() </span><br><span class="line">          </span><br><span class="line">thread1 &#x3D; thread(100) </span><br><span class="line">thread2 &#x3D; thread(101) </span><br><span class="line">  </span><br><span class="line">thread1.start() </span><br><span class="line">thread2.start() </span><br><span class="line">  </span><br><span class="line">barrier.wait() </span><br><span class="line">  </span><br><span class="line">print(str(barrier.broken) + &quot;\n&quot;) </span><br><span class="line">barrier.reset() </span><br><span class="line">print(&quot;n_waiting after reset &#x3D; &quot; + str(barrier.n_waiting)) </span><br><span class="line">barrier.abort() </span><br><span class="line">print(&quot;End&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>The threading module of Python includes locks as a synchronization tool. A lock has two states:<br>locked and unlocked.<br>A lock can be locked using the acquire() method. Once a thread has acquired the lock, all subsequent attempts to acquire the lock are blocked until it is released. The lock can be released using the release() method.</p>
<p>Calling the release() method on a lock, in an unlocked state, results in an error.</p>
<p>Let us take an example to see how to make use lock to solve a race condition problem.</p>
<p>Race condition is a significant problem in concurrent programming. The condition occurs when one thread tries to modify a shared resource at the same time that another thread is modifying that resource – t​his leads to garbled output, which is why threads need to be synchronized.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Importing the threading module</span><br><span class="line">import threading </span><br><span class="line"># Declraing a lock</span><br><span class="line">lock &#x3D; threading.Lock()</span><br><span class="line">deposit &#x3D; 100</span><br><span class="line"># Function to add profit to the deposit</span><br><span class="line">def add_profit(): </span><br><span class="line">    global deposit</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        deposit &#x3D; deposit + 10</span><br><span class="line">        lock.release()</span><br><span class="line"># Function to deduct money from the deposit</span><br><span class="line">def pay_bill(): </span><br><span class="line">    global deposit</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        deposit &#x3D; deposit - 10</span><br><span class="line">        lock.release()</span><br><span class="line"># Creating threads</span><br><span class="line">thread1 &#x3D; threading.Thread(target &#x3D; add_profit, args &#x3D; ())</span><br><span class="line">thread2 &#x3D; threading.Thread(target &#x3D; pay_bill, args &#x3D; ())</span><br><span class="line"># Starting the threads  </span><br><span class="line">thread1.start() </span><br><span class="line">thread2.start() </span><br><span class="line"># Waiting for both the threads to finish executing </span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"># Displaying the final value of the deposit</span><br><span class="line">print(deposit)</span><br></pre></td></tr></table></figure>


<p>Let us use a list variable to record the whole process how deposit changes alone the way.<br>If we do not have the lock.acquire() and lock.release(), the result may looks like below when there is no lock.acquire() and lock.release() present:</p>
<p>With the usage of lock.acquire() and lock.release(), it will be like:</p>
<h1 id="Semaphore-Object"><a href="#Semaphore-Object" class="headerlink" title="Semaphore Object"></a>Semaphore Object</h1><p>A semaphore manages an internal counter which is decremented by each acquire() call and incremented by each release() call. The counter can never go below zero; when acquire() finds that it is zero, it blocks, waiting until some other thread calls release().</p>
<p>There are several main methods available from this object:</p>
<h5 id="acquire-blocking-True-timeout-None"><a href="#acquire-blocking-True-timeout-None" class="headerlink" title="acquire(blocking=True, timeout=None):"></a>acquire(blocking=True, timeout=None):</h5><h5 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h5><h1 id="Mutex-Lock-VS-Semaphore"><a href="#Mutex-Lock-VS-Semaphore" class="headerlink" title="Mutex(Lock) VS Semaphore"></a>Mutex(Lock) VS Semaphore</h1><p>As we can tell, the methods we have from Lock instance are pretty similar to the methods we have from Semaphore. Then what is the difference between Mutex and Semaphore ?</p>
<p>Mutex is a mutual exclusion object that synchronizes access to a resource. It is created with a unique name at the start of a program. The Mutex is a locking mechanism that makes sure only one thread can acquire the Mutex at a time and enter the critical section. This thread only releases the Mutex when it exits the critical section.</p>
<p>A semaphore is a signalling mechanism and a thread that is waiting on a semaphore can be signaled by another thread. This is different than a mutex as the mutex can be signaled only by the thread that called the wait function.</p>
<p>There are mainly two types of semaphores i.e. counting semaphores and binary semaphores.</p>
<p>Counting Semaphores are integer value semaphores and have an unrestricted value domain. These semaphores are used to coordinate the resource access, where the semaphore count is the number of available resources.</p>
<p>The binary semaphores are like counting semaphores but their value is restricted to 0 and 1. The wait operation only works when the semaphore is 1 and the signal operation succeeds when semaphore is 0.</p>
<h1 id="Event-Object"><a href="#Event-Object" class="headerlink" title="Event Object"></a>Event Object</h1><p>One thread can signal an event and other threads wait for it.<br>There are several main methods available from this object:</p>
<h5 id="isSet"><a href="#isSet" class="headerlink" title="isSet()"></a>isSet()</h5><p>Return true if and only if the internal flag is true</p>
<h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call wait() once the flag is true will not block at all.</p>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>Reset the internal flag to false. Subsequently, threads calling wait() will block until set() is called to set the internal flag to true again.</p>
<h4 id="wait-timeout-in-seconds"><a href="#wait-timeout-in-seconds" class="headerlink" title="wait([timeout in seconds])"></a>wait([timeout in seconds])</h4><p>Block until the internal flag is true.</p>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>There are several main methods available from this object:</p>
<h5 id="Condition-lock"><a href="#Condition-lock" class="headerlink" title="Condition([lock])"></a>Condition([lock])</h5><p>If the lock argument is given and not None, it must be a Lock or RLock object, and it is used as the underlying lock. Otherwise, a new RLock object is created and used as the underlying lock.</p>
<h5 id="acquire-args"><a href="#acquire-args" class="headerlink" title="acquire(*args)"></a>acquire(*args)</h5><p>Acquire the underlying lock. This method calls the corresponding method on the underlying lock; the return value is whatever that method returns.</p>
<h5 id="release-1"><a href="#release-1" class="headerlink" title="release ()"></a>release ()</h5><p>Release the underlying lock. This method calls the corresponding method on the underlying lock; there is no return value.</p>
<h5 id="wait-timeout"><a href="#wait-timeout" class="headerlink" title="wait([timeout])"></a>wait([timeout])</h5><h5 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h5><p>Wake up a thread waiting on this condition, if any. This must only be called when the calling thread has acquired the lock.</p>
<h5 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h5><p>Wake up all threads waiting on this condition.</p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>Ok. At the end, let see a problem which can be solved by making use Brutal force, Barrier, Event, Condition, Lock and Semaphore.</p>
<p>Problem description<br>Suppose we have a class:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def first():</span><br><span class="line">	printFirst()</span><br><span class="line">    def second():</span><br><span class="line">        printSecond()    </span><br><span class="line">    def third():</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<p>Now we have an instance of Foo which will be passed to 3 different threads. Thread A will call first(), thread B will call second(), thread C will call third(). Design a mechanism to ensure that the second() is executed after first(), third() is executed after second().</p>
<h3 id="Brutal-Force"><a href="#Brutal-Force" class="headerlink" title="Brutal Force"></a>Brutal Force</h3><p>We definite can make use of a very brutal force way to solve this problem by setting a flag with in the class. Until the flag was trigger, we are not able to move forward. Refer to the code below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.status &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        # printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span><br><span class="line">        while self.status !&#x3D; 0:</span><br><span class="line">            time.sleep(0.001)</span><br><span class="line">        printFirst()</span><br><span class="line">        self.status &#x3D; 1</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        # printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span><br><span class="line">        while self.status !&#x3D; 1:</span><br><span class="line">            time.sleep(0.001)</span><br><span class="line">        printSecond()</span><br><span class="line">        self.status &#x3D; 2</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        # printThird() outputs &quot;third&quot;. Do not change or remove this line.</span><br><span class="line">        while self.status !&#x3D; 2:</span><br><span class="line">            time.sleep(0.001)</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Barrier-1"><a href="#Barrier-1" class="headerlink" title="Barrier"></a>Barrier</h3><p>Raise two barriers. Both wait for two threads to reach them.</p>
<p>First thread can print before reaching the first barrier. Second thread can print before reaching the second barrier. Third thread can print after the second barrier.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from threading import Barrier</span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.first_barrier &#x3D; Barrier(2)</span><br><span class="line">        self.second_barrier &#x3D; Barrier(2)</span><br><span class="line">            </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.first_barrier.wait()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        self.first_barrier.wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.second_barrier.wait()</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        self.second_barrier.wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Lock-Mutex"><a href="#Lock-Mutex" class="headerlink" title="Lock (Mutex)"></a>Lock (Mutex)</h3><p>Start with two locked locks. First thread unlocks the first lock that the second thread is waiting on. Second thread unlocks the second lock that the third thread is waiting on.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from threading import Lock</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.locks &#x3D; (Lock(),Lock())</span><br><span class="line">        self.locks[0].acquire()</span><br><span class="line">        self.locks[1].acquire()</span><br><span class="line">        </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.locks[0].release()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        with self.locks[0]:</span><br><span class="line">            printSecond()</span><br><span class="line">            self.locks[1].release()</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        with self.locks[1]:</span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Start with two closed gates represented by 0-value semaphores. Second and third thread are waiting behind these gates. When the first thread prints, it opens the gate for the second thread. When the second thread prints, it opens the gate for the third thread.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from threading import Semaphore</span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.gates &#x3D; (Semaphore(0),Semaphore(0))</span><br><span class="line">        </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.gates[0].release()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        with self.gates[0]:</span><br><span class="line">            printSecond()</span><br><span class="line">            self.gates[1].release()</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        with self.gates[1]:</span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>Set events from first and second threads when they are done. Have the second thread wait for first one to set its event. Have the third thread wait on the second thread to raise its event.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from threading import Event</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.done &#x3D; (Event(),Event())</span><br><span class="line">        </span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        printFirst()</span><br><span class="line">        self.done[0].set()</span><br><span class="line">        </span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        self.done[0].wait()</span><br><span class="line">        printSecond()</span><br><span class="line">        self.done[1].set()</span><br><span class="line">            </span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        self.done[1].wait()</span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure>

<h3 id="Condition-1"><a href="#Condition-1" class="headerlink" title="Condition"></a>Condition</h3><p>Have all three threads attempt to acquire an RLock via Condition. The first thread can always acquire a lock, while the other two have to wait for the order to be set to the right value. First thread sets the order after printing which signals for the second thread to run. Second thread does the same for the third.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from threading import Condition</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.exec_condition &#x3D; Condition()</span><br><span class="line">        self.order &#x3D; 0</span><br><span class="line">        self.first_finish &#x3D; lambda: self.order &#x3D;&#x3D; 1</span><br><span class="line">        self.second_finish &#x3D; lambda: self.order &#x3D;&#x3D; 2</span><br><span class="line"></span><br><span class="line">    def first(self, printFirst):</span><br><span class="line">        with self.exec_condition:</span><br><span class="line">            printFirst()</span><br><span class="line">            self.order &#x3D; 1</span><br><span class="line">            self.exec_condition.notify(2)</span><br><span class="line"></span><br><span class="line">    def second(self, printSecond):</span><br><span class="line">        with self.exec_condition:</span><br><span class="line">            self.exec_condition.wait_for(self.first_finish)</span><br><span class="line">            printSecond()</span><br><span class="line">            self.order &#x3D; 2</span><br><span class="line">            self.exec_condition.notify()</span><br><span class="line"></span><br><span class="line">    def third(self, printThird):</span><br><span class="line">        with self.exec_condition:</span><br><span class="line">            self.exec_condition.wait_for(self.second_finish)</span><br><span class="line">            printThird()</span><br></pre></td></tr></table></figure>
<p>Referrence:<br><a href="https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation" target="_blank" rel="noopener">https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation</a><br><a href="https://www.geeksforgeeks.org/barrier-objects-python/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/barrier-objects-python/</a><br><a href="https://www.educative.io/edpresso/what-are-locks-in-python" target="_blank" rel="noopener">https://www.educative.io/edpresso/what-are-locks-in-python</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/28/Multi-Threading%20in%20Python/" data-id="ck8bu1s4a0000shsj0k761x51" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Parallel-Computing/" rel="tag">Parallel Computing</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/27/hello-world/" class="article-date">
  <time datetime="2020-03-28T00:59:31.373Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/27/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/27/hello-world/" data-id="ck8az0g7t0002d7sjcgdt1lvo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Lidar-Data-PostProcessing1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/25/Lidar-Data-PostProcessing1/" class="article-date">
  <time datetime="2020-03-26T03:48:25.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Autonomous-Driving/">Autonomous Driving</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/25/Lidar-Data-PostProcessing1/">Lidar Data PostProcessing1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/25/Lidar-Data-PostProcessing1/" data-id="ck8az0g7n0000d7sjg4u2enez" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Parallel Computing1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2020/03/25/Parallel%20Computing1/" class="article-date">
  <time datetime="2020-03-26T03:48:25.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/Parallel-Computing/">Parallel Computing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2020/03/25/Parallel%20Computing1/">Parallel Computing 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In order to understand how parallel computing works, we have to understand a few concepts.<br>A multithreaded computation can be represetned by a Directed Acyclic Graph of vertices. Each vertex represents the executtion of an instruction.<br>First of all, let`s take a look at 2 concepts:<br>Cost model: Work and Span:</p>
<h5 id="Work"><a href="#Work" class="headerlink" title="Work"></a>Work</h5><p>The total work that will be executed by all the processors.<br>If we consider the whole process that a computer finish all the tasks as a Directed Acyclic Graph, then work is the total number of all vertices of the DAG.</p>
<p>Span: sometime we call it depth, is the length of the longest path of the<br>DAG(critical path). </p>
<p>See the picture below, work == 21, span == 8<br><img src="/images/Parallel Computing1/work_and_span.jpg" width="400" hegiht="400"></p>
<p>Brent`s Theorem:<br>Brent`s theorem is the theorem to give the upper bound and lower bound of the time that expires between the start of the computation and its end. Let us<br>denote it as Tp, denote total work as W, Span as D, number of processors as N.<br><img src="/images/Parallel Computing1/brent_theorem.jpg" width="400" hegiht="400"></p>
<p>Then we can easily have:<br>Tp =  ∑(1 to D)(floor(Wi-1)/P) + 1<br>based on the properties of ceiling and floor operation, we have<br>max(D, ceiling(W/N)) &lt;= Tp &lt;= (W-D)/N + D</p>
<p>par-for loop:<br>(parallel for loop, sometimes people call it for-any loop or for-all loop)<br>All iterations are independent to each other.</p>
<img src="/images/Parallel Computing1/par_for.jpg" width="400" height="400"/>

<p>The DAG above shows how does a offline scheduling problem works. In reality, we might don`t have full knowledge of the DAG. Instead, the DAG unfolds as we run the program. Futhermore, we are interested in not only minimizing the length of the schedule but also the work and time it takes to compute the schedule. These 2 conditions defin the online scheduling problem.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/XunOuyang/xunouyang.github.io/blob/master/2020/03/25/Parallel%20Computing1/" data-id="ck8az0g7r0001d7sjfj0qhd22" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Parallel-Computing/" rel="tag">Parallel Computing</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="categories/Autonomous-Driving/">Autonomous Driving</a></li><li class="category-list-item"><a class="category-list-link" href="categories/Machine-Learning/">Machine Learning</a></li><li class="category-list-item"><a class="category-list-link" href="categories/Parallel-Computing/">Parallel Computing</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Autonomous-Driving/" rel="tag">Autonomous Driving</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Deep-Learning/" rel="tag">Deep Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Machine-Learning/" rel="tag">Machine Learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Parallel-Computing/" rel="tag">Parallel Computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Radar/" rel="tag">Radar</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Sensor-Fusion/" rel="tag">Sensor Fusion</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="tags/Autonomous-Driving/" style="font-size: 15px;">Autonomous Driving</a> <a href="tags/Deep-Learning/" style="font-size: 10px;">Deep Learning</a> <a href="tags/Machine-Learning/" style="font-size: 15px;">Machine Learning</a> <a href="tags/Parallel-Computing/" style="font-size: 20px;">Parallel Computing</a> <a href="tags/Radar/" style="font-size: 15px;">Radar</a> <a href="tags/Sensor-Fusion/" style="font-size: 10px;">Sensor Fusion</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2020/07/12/hungarian%20algorithm/">Hungarian Algorithm</a>
          </li>
        
          <li>
            <a href="2020/05/10/Radar%20Tracker/">Radar Tracker</a>
          </li>
        
          <li>
            <a href="2020/05/03/Deep%20Learning%20Bag%20of%20Freebies/">Deep Learning Bag of Freebies</a>
          </li>
        
          <li>
            <a href="2020/04/26/Bitonic_Sort/">双调排序 Bitonic Sort</a>
          </li>
        
          <li>
            <a href="2020/03/29/Parallel%20Computing%202/">Parallel Computing 2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Ivan Xun Ouyang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="fancybox/jquery.fancybox.css">

  
<script src="fancybox/jquery.fancybox.pack.js"></script>




<script src="js/script.js"></script>




  </div>
</body>
</html>